#!/usr/bin/env bash
# ─────────────────────────────────────────────────────────────────────────────
# chezmoi-daemon - Scheduled enforcement daemon for chezmoi self-heal
# Managed by Chezmoi
# ─────────────────────────────────────────────────────────────────────────────
#
# This daemon runs periodically (via launchd) to:
#   1. Pull latest changes from remote
#   2. Detect configuration drift
#   3. Optionally auto-apply fixes
#   4. Send notifications when attention needed
#
# Usage:
#   chezmoi-daemon              # Dry-run (detect only, no changes)
#   chezmoi-daemon --apply      # Actually apply fixes
#   chezmoi-daemon --force      # Skip idle check and interval limits
#
# Exit codes:
#   0 - Success (no drift or drift fixed)
#   1 - Drift detected (in dry-run mode)
#   2 - Error occurred
#   3 - Skipped (user active, too soon since last run, etc.)

set -euo pipefail

# ─────────────────────────────────────────────────────────────────────────────
# Configuration
# ─────────────────────────────────────────────────────────────────────────────

STATE_DIR="${HOME}/.local/share/chezmoi-health"
BACKUP_DIR="${STATE_DIR}/backups"
LOG_FILE="${STATE_DIR}/daemon.log"
LOCK_FILE="${STATE_DIR}/daemon.lock"
LAST_RUN_FILE="${STATE_DIR}/last-daemon-run"
FAILURE_COUNT_FILE="${STATE_DIR}/failure-count"
CONFIG_FILE="${HOME}/.config/chezmoi-daemon/config"
CHEZMOI_SOURCE="{{ .chezmoi.sourceDir }}"

# Defaults (can be overridden by config file)
AUTO_APPLY="${AUTO_APPLY:-false}"
AUTO_PULL="${AUTO_PULL:-true}"
NOTIFY_ON_DRIFT="${NOTIFY_ON_DRIFT:-true}"
MIN_INTERVAL_SECONDS="${MIN_INTERVAL_SECONDS:-3600}"  # 1 hour
ONLY_WHEN_IDLE="${ONLY_WHEN_IDLE:-true}"
IDLE_THRESHOLD_SECONDS="${IDLE_THRESHOLD_SECONDS:-300}"  # 5 minutes
MAX_BACKUPS="${MAX_BACKUPS:-10}"
FAILURE_ESCALATION_THRESHOLD="${FAILURE_ESCALATION_THRESHOLD:-3}"

# Runtime flags
DO_APPLY=0
FORCE_RUN=0

# ─────────────────────────────────────────────────────────────────────────────
# Parse arguments
# ─────────────────────────────────────────────────────────────────────────────

while [[ $# -gt 0 ]]; do
  case "$1" in
    --apply)
      DO_APPLY=1
      shift
      ;;
    --force)
      FORCE_RUN=1
      shift
      ;;
    --help|-h)
      echo "Usage: chezmoi-daemon [--apply] [--force]"
      echo ""
      echo "Options:"
      echo "  --apply   Actually apply changes (default: dry-run)"
      echo "  --force   Skip idle check and interval limits"
      exit 0
      ;;
    *)
      shift
      ;;
  esac
done

# ─────────────────────────────────────────────────────────────────────────────
# Load config file if exists
# ─────────────────────────────────────────────────────────────────────────────

if [[ -f "${CONFIG_FILE}" ]]; then
  # shellcheck source=/dev/null
  source "${CONFIG_FILE}"
fi

# ─────────────────────────────────────────────────────────────────────────────
# Logging
# ─────────────────────────────────────────────────────────────────────────────

mkdir -p "${STATE_DIR}"
mkdir -p "${BACKUP_DIR}"

log() {
  local level="$1"
  shift
  local timestamp
  timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  echo "[${timestamp}] [${level}] $*" >> "${LOG_FILE}"

  # Also print to stdout for manual runs
  if [[ -t 1 ]]; then
    echo "[${level}] $*"
  fi
}

log_rotate() {
  # Keep log file under 1MB; preserve last 500 lines for context
  if [[ -f "${LOG_FILE}" ]]; then
    local size
    size=$(stat -f%z "${LOG_FILE}" 2>/dev/null || stat -c%s "${LOG_FILE}" 2>/dev/null || echo 0)
    if [[ ${size} -gt 1048576 ]]; then
      tail -500 "${LOG_FILE}" >"${LOG_FILE}.new" && mv "${LOG_FILE}.new" "${LOG_FILE}"
    fi
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Notifications (macOS)
# ─────────────────────────────────────────────────────────────────────────────

notify() {
  local title="$1"
  local message="$2"
  local subtitle="${3:-}"

  {{- if eq .chezmoi.os "darwin" }}
  osascript -e "display notification \"${message}\" with title \"${title}\" subtitle \"${subtitle}\"" 2>/dev/null || true
  {{- end }}
}

# ─────────────────────────────────────────────────────────────────────────────
# Lock management
# ─────────────────────────────────────────────────────────────────────────────

acquire_lock() {
  if [[ -f "${LOCK_FILE}" ]]; then
    local pid
    pid=$(cat "${LOCK_FILE}")
    if kill -0 "${pid}" 2>/dev/null; then
      log "WARN" "Another instance running (PID ${pid})"
      return 1
    fi
    # Stale lock file
    rm -f "${LOCK_FILE}"
  fi

  echo $$ > "${LOCK_FILE}"
  trap 'rm -f "${LOCK_FILE}"' EXIT
  return 0
}

# ─────────────────────────────────────────────────────────────────────────────
# Interval checking
# ─────────────────────────────────────────────────────────────────────────────

check_interval() {
  if [[ ! -f "${LAST_RUN_FILE}" ]]; then
    return 0  # First run
  fi

  local last_run
  last_run=$(cat "${LAST_RUN_FILE}")
  local now
  now=$(date +%s)
  local elapsed=$((now - last_run))

  if [[ ${elapsed} -lt ${MIN_INTERVAL_SECONDS} ]]; then
    local remaining=$((MIN_INTERVAL_SECONDS - elapsed))
    log "INFO" "Skipping: ${remaining}s until next allowed run"
    return 1
  fi

  return 0
}

record_run() {
  date +%s > "${LAST_RUN_FILE}"
}

# ─────────────────────────────────────────────────────────────────────────────
# Idle detection (macOS)
# ─────────────────────────────────────────────────────────────────────────────

check_idle() {
  {{- if eq .chezmoi.os "darwin" }}
  local idle_time
  idle_time=$(ioreg -c IOHIDSystem | awk -F'= ' '/HIDIdleTime/ {print int($2/1000000000); exit}')

  if [[ ${idle_time} -lt ${IDLE_THRESHOLD_SECONDS} ]]; then
    log "INFO" "User active (idle: ${idle_time}s < ${IDLE_THRESHOLD_SECONDS}s threshold)"
    return 1
  fi

  log "DEBUG" "User idle for ${idle_time}s"
  {{- end }}
  return 0
}

# ─────────────────────────────────────────────────────────────────────────────
# Failure tracking
# ─────────────────────────────────────────────────────────────────────────────

get_failure_count() {
  if [[ -f "${FAILURE_COUNT_FILE}" ]]; then
    cat "${FAILURE_COUNT_FILE}"
  else
    echo 0
  fi
}

increment_failure() {
  local count
  count=$(get_failure_count)
  echo $((count + 1)) > "${FAILURE_COUNT_FILE}"
}

reset_failures() {
  echo 0 > "${FAILURE_COUNT_FILE}"
}

check_failure_escalation() {
  local count
  count=$(get_failure_count)

  if [[ ${count} -ge ${FAILURE_ESCALATION_THRESHOLD} ]]; then
    log "ERROR" "Failure threshold reached (${count} consecutive failures)"
    notify "Chezmoi Self-Heal" "Failed ${count} times consecutively. Manual intervention needed." "Error"
    return 1
  fi

  return 0
}

# ─────────────────────────────────────────────────────────────────────────────
# Backup management
# ─────────────────────────────────────────────────────────────────────────────

create_backup() {
  local files="$1"

  if [[ -z "${files}" ]]; then
    return 0
  fi

  local backup_name
  backup_name="backup-$(date +%Y%m%d-%H%M%S)"
  local backup_path="${BACKUP_DIR}/${backup_name}"

  mkdir -p "${backup_path}"

  # Back up each changed file
  echo "${files}" | while read -r file; do
    [[ -z "${file}" ]] && continue
    local target="${HOME}/${file}"
    if [[ -f "${target}" ]]; then
      local dir
      dir=$(dirname "${file}")
      mkdir -p "${backup_path}/${dir}"
      cp "${target}" "${backup_path}/${file}"
    fi
  done

  log "INFO" "Backup created: ${backup_name}"
  echo "${backup_name}"

  # Rotate old backups
  rotate_backups
}

rotate_backups() {
  local count
  count=$(find "${BACKUP_DIR}" -maxdepth 1 -type d -name 'backup-*' | wc -l | tr -d ' ')

  if [[ ${count} -gt ${MAX_BACKUPS} ]]; then
    local to_remove=$((count - MAX_BACKUPS))
    find "${BACKUP_DIR}" -maxdepth 1 -type d -name 'backup-*' | sort | head -${to_remove} | while read -r dir; do
      rm -rf "${dir}"
      log "INFO" "Removed old backup: $(basename "${dir}")"
    done
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Core operations
# ─────────────────────────────────────────────────────────────────────────────

pull_remote() {
  if [[ "${AUTO_PULL}" != "true" ]]; then
    return 0
  fi

  if [[ ! -d "${CHEZMOI_SOURCE}/.git" ]]; then
    log "WARN" "Source is not a git repo, skipping pull"
    return 0
  fi

  log "INFO" "Pulling from remote..."

  if (cd "${CHEZMOI_SOURCE}" && git pull --ff-only 2>&1); then
    log "INFO" "Pull successful"
    return 0
  else
    log "WARN" "Pull failed (may need manual intervention)"
    return 1
  fi
}

detect_drift() {
  log "INFO" "Checking for drift..."

  local diff_output
  diff_output=$(chezmoi diff 2>&1) || true

  if [[ -z "${diff_output}" ]]; then
    log "INFO" "No drift detected"
    return 0
  fi

  # Extract changed file paths
  local changed_files
  changed_files=$(echo "${diff_output}" | grep -E '^\+\+\+ b/' | sed 's/^+++ b\///' | sort -u)

  local count
  count=$(echo "${changed_files}" | grep -c . || echo 0)

  log "WARN" "Drift detected in ${count} file(s)"
  echo "${changed_files}"

  return 1
}

apply_changes() {
  local drifted_files="$1"

  if [[ ${DO_APPLY} -eq 0 ]]; then
    log "INFO" "Dry-run mode: would apply changes to: ${drifted_files}"
    return 1  # Return 1 to indicate drift exists but not fixed
  fi

  # Create backup before applying
  create_backup "${drifted_files}"

  log "INFO" "Applying chezmoi changes..."

  if chezmoi apply --force 2>&1; then
    log "INFO" "Changes applied successfully"
    reset_failures
    return 0
  else
    log "ERROR" "Failed to apply changes"
    increment_failure
    return 2
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Main
# ─────────────────────────────────────────────────────────────────────────────

main() {
  log_rotate

  log "INFO" "Daemon started (apply=${DO_APPLY}, force=${FORCE_RUN})"

  # Acquire lock
  if ! acquire_lock; then
    exit 3
  fi

  # Check interval (unless forced)
  if [[ ${FORCE_RUN} -eq 0 ]] && ! check_interval; then
    exit 3
  fi

  # Check idle (unless forced)
  if [[ ${FORCE_RUN} -eq 0 ]] && [[ "${ONLY_WHEN_IDLE}" == "true" ]] && ! check_idle; then
    exit 3
  fi

  # Check failure escalation
  if ! check_failure_escalation; then
    exit 2
  fi

  record_run

  # Pull latest from remote
  pull_remote || true  # Continue even if pull fails

  # Detect drift
  local drifted_files
  drifted_files=$(detect_drift) || {
    local exit_code=$?
    if [[ ${exit_code} -eq 1 ]]; then
      # Drift detected
      if [[ "${NOTIFY_ON_DRIFT}" == "true" ]]; then
        local count
        count=$(echo "${drifted_files}" | grep -c . || echo 0)
        notify "Chezmoi Self-Heal" "${count} file(s) have drifted from source" "Drift Detected"
      fi

      # Apply if configured
      if [[ "${AUTO_APPLY}" == "true" || ${DO_APPLY} -eq 1 ]]; then
        apply_changes "${drifted_files}"
        exit $?
      fi

      log "INFO" "Run with --apply to fix drift"
      exit 1
    fi
  }

  # No drift
  reset_failures
  log "INFO" "System healthy, no action needed"
  exit 0
}

main
